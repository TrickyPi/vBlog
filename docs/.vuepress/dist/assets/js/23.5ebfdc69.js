(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{267:function(e,t,a){"use strict";a.r(t);var s=a(28),r=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"vue3与vue2区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue3与vue2区别"}},[e._v("#")]),e._v(" Vue3与Vue2区别")]),e._v(" "),a("h2",{attrs:{id:"composition-api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#composition-api"}},[e._v("#")]),e._v(" Composition Api")]),e._v(" "),a("p",[e._v("顾名思义，"),a("code",[e._v("Composition Api")]),e._v("相当与一个组合式的开发方式，更像是一种根据逻辑来开发的一种行为；")]),e._v(" "),a("p",[e._v("在Vue2中，我们更多的是遵守配置式的开发，比如Vue组件中暴露出的一些"),a("code",[e._v("Option")]),e._v("配置，把我们需要写的逻辑代码分散的写到这些选项中；\n这样的话，不仅会造成我们的代码分散，不易阅读，更重要的一点是，当我们需要抽离组件内的功能变成复用功能时就变得十分困难；当然在vue2\n中我们可以使用mixin来实现；不过mixin存在很多隐藏问题；\n因此在Vue3中就出现了composition Api；这个其实跟react的hook就有一点相似；")]),e._v(" "),a("h2",{attrs:{id:"tree-shanke"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tree-shanke"}},[e._v("#")]),e._v(" tree shanke")]),e._v(" "),a("p",[e._v("Vue2中的一些基本"),a("code",[e._v("Option")]),e._v("配置，比如computed，watch，等是不支持tree shanke，Vue3支持后，假如一些Option配置没有用到，打包时就不会把这些实现代码打包到项目中；进一步减少了项目体积")]),e._v(" "),a("h2",{attrs:{id:"源码上"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#源码上"}},[e._v("#")]),e._v(" 源码上")]),e._v(" "),a("h3",{attrs:{id:"数据劫持的实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据劫持的实现"}},[e._v("#")]),e._v(" 数据劫持的实现")]),e._v(" "),a("p",[e._v("数据劫持的实现在Vue2和Vue3中有跟大的区别，首先Vue2使用的是"),a("code",[e._v("Object.definePrototype()")]),e._v("实现的，而Vue3是基于ES6的"),a("code",[e._v("Proxy")]),e._v("api实现的；\n两种实现有啥区别呢；\n第一种实现方式：\n1.将会兼容更低版本的浏览器\n第二种实现方式：\n1.")]),e._v(" "),a("h3",{attrs:{id:"diff的优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#diff的优化"}},[e._v("#")]),e._v(" diff的优化")]),e._v(" "),a("p",[e._v("Vue3对比于Vue2，他在diff比较上有了优化，首先会有一个"),a("code",[e._v("patch flag")]),e._v("概念")])])}),[],!1,null,null,null);t.default=r.exports}}]);